// RobotBuilder Version: 6.1
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

// ROBOTBUILDER TYPE: Subsystem.

package frc.robot.subsystems;

import com.revrobotics.CANSparkBase.IdleMode;
import com.revrobotics.CANSparkFlex;
import com.revrobotics.CANSparkLowLevel.MotorType;
import com.revrobotics.CANSparkMax;
import com.revrobotics.SparkPIDController;

import edu.wpi.first.wpilibj.DigitalInput;
import edu.wpi.first.wpilibj.DoubleSolenoid;
import edu.wpi.first.wpilibj.DoubleSolenoid.Value;
import edu.wpi.first.wpilibj.PneumaticsModuleType;
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.wpilibj2.command.SubsystemBase;
import frc.robot.Constants;
import frc.robot.RobotContainer;

/**
 *
 */
public class Spamp extends SubsystemBase {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
private CANSparkMax bottomLeft;
private CANSparkFlex topRight;
private CANSparkMax midLeft;
private CANSparkFlex topLeft;
private DigitalInput noteDetectorSpampBottom;
private DoubleSolenoid shootSolenoid;
private DigitalInput noteDetectorSpampTop;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private SparkPIDController topRightController;
    private SparkPIDController topLeftController;

    // sets default rpm for motors
    public double defaultRPM = 240;
    public double kP, kI, kD, kIz, kFF, kMaxOutput, kMinOutput, maxRPM;


    // this should get the speed the shaft spins at full power
    private double midLeftGearRatio = Constants.MaxRPMConstants.maxRPMNeo / 3;
    private double bottomLeftGearRatio = Constants.MaxRPMConstants.maxRPMNeo550 / 10;

    public double bottomRightSpeed;
    public double bottomLeftSpeed;
    public double topLeftSpeed;
    public double topRightSpeed;

    private boolean transferring;

    /**
    *
    */
    public Spamp() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
bottomLeft = new CANSparkMax(25, MotorType.kBrushless);
 
   
bottomLeft.setInverted(true);
bottomLeft.setIdleMode(IdleMode.kBrake);
bottomLeft.burnFlash();
  

topRight = new CANSparkFlex(28, MotorType.kBrushless);
 
   
topRight.setInverted(true);
topRight.setIdleMode(IdleMode.kBrake);
topRight.burnFlash();
  

midLeft = new CANSparkMax(24, MotorType.kBrushless);
 
   
midLeft.setInverted(false);
midLeft.setIdleMode(IdleMode.kBrake);
midLeft.burnFlash();
  

topLeft = new CANSparkFlex(27, MotorType.kBrushless);
 
   
topLeft.setInverted(false);
topLeft.setIdleMode(IdleMode.kBrake);
topLeft.burnFlash();
  

noteDetectorSpampBottom = new DigitalInput(2);
 addChild("noteDetectorSpampBottom", noteDetectorSpampBottom);
 

shootSolenoid = new DoubleSolenoid(20, PneumaticsModuleType.REVPH, 14,15);
 addChild("shootSolenoid", shootSolenoid);
 

noteDetectorSpampTop = new DigitalInput(3);
 addChild("noteDetectorSpampTop", noteDetectorSpampTop);
 


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
        bottomLeft.setSmartCurrentLimit(40);
        midLeft.setSmartCurrentLimit(120);
        topLeft.setSmartCurrentLimit(60);
        topRight.setSmartCurrentLimit(60);
        topRightController = topRight.getPIDController();
        topLeftController = topLeft.getPIDController();

        // PID coefficients
        kP = 6e-5;
        kI = 0;
        kD = 0;
        kIz = 0;
        kFF = 0.000015;
        kMaxOutput = 1;
        kMinOutput = -1;
        maxRPM = 5700;

        // set PID coefficients
        topRightController.setP(kP);
        topRightController.setI(kI);
        topRightController.setD(kD);
        topRightController.setIZone(kIz);
        topRightController.setFF(kFF);
        topRightController.setOutputRange(kMinOutput, kMaxOutput);
        topLeftController.setP(kP);
        topLeftController.setI(kI);
        topLeftController.setD(kD);
        topLeftController.setIZone(kIz);
        topLeftController.setFF(kFF);
        topLeftController.setOutputRange(kMinOutput, kMaxOutput);

        shootSolenoid.set(Value.kReverse);

    }

    @Override
    public void periodic() {
        // This method will be called once per scheduler run
        SmartDashboard.putNumber("BL-Velocity", bottomLeft.getEncoder().getVelocity());
        SmartDashboard.putNumber("ML-Velocity", midLeft.getEncoder().getVelocity());
        SmartDashboard.putNumber("TL-Velocity", topLeft.getEncoder().getVelocity());
        SmartDashboard.putNumber("TR-Velocity", topRight.getEncoder().getVelocity());
        SmartDashboard.putBoolean("Note in Spamp", isNoteInSpamp());
        SmartDashboard.putBoolean("isReadyToShootSpeaker", isAtRPM(Constants.SpampConstants.speakerRPM));
        SmartDashboard.putBoolean("isReadyToShootAmp", isAtRPM(Constants.SpampConstants.ampRPM));
        SmartDashboard.putBoolean("Note Leaving Spamp", noteDetectorSpampTop.get());

        if (RobotContainer.getInstance().m_acquisition.readyToTransfer()) {
            transferring = true;

        }
        if (transferring) {
            runBottom();
            if (!RobotContainer.getInstance().m_acquisition.isNoteInAcquisition() &&
                    isNoteInSpamp()) {
                stopall();
                RobotContainer.getInstance().m_acquisition.stopBoth();
                transferring = false;
            }
        }

        // if (!RobotContainer.getInstance().m_aquisition.isNoteInAquisition() &
        // !isNoteInSpamp()) {
        // transferring = false;
        // stopall();
        // }

    }

    @Override
    public void simulationPeriodic() {
        // This method will be called once per scheduler run when in simulation

    }

    // Put methods for controlling this subsystem
    // here. Call these from Commands.
    public void runAll() {
        bottomRightSpeed = SmartDashboard.getNumber("BR-RPM", defaultRPM);
        bottomLeftSpeed = SmartDashboard.getNumber("BL-RPM", defaultRPM);
        topRightSpeed = SmartDashboard.getNumber("TR-RPM", defaultRPM);
        topLeftSpeed = SmartDashboard.getNumber("TL-RPM", defaultRPM);

        bottomLeft.set(bottomLeftSpeed / bottomLeftGearRatio);
        midLeft.set(bottomRightSpeed / midLeftGearRatio);
        topLeft.set(topLeftSpeed / Constants.MaxRPMConstants.maxRPMVortex);
        topRight.set(topRightSpeed / Constants.MaxRPMConstants.maxRPMVortex);
    }

    // public void speakerSpinToRPM() {
    //     topLeftController.setReference(Constants.SpampConstants.speakerRPM * 2.96, CANSparkFlex.ControlType.kVelocity);
    //     topRightController.setReference(Constants.SpampConstants.speakerRPM * 2.96, CANSparkFlex.ControlType.kVelocity);
    // }

    // public void ampSpinToRPM() {
    //     topRightController.setReference(Constants.SpampConstants.ampRPM * 2.96, CANSparkFlex.ControlType.kVelocity);
    // }

    public boolean isAtRPM(double rpms) {
        SmartDashboard.putNumber("rpms", rpms);
        SmartDashboard.putNumber("velocity", topRight.getEncoder().getVelocity());

        if (Math.abs(topRight.getEncoder().getVelocity()) >= rpms - 50) {
            return true;
        }
        return false;
    }

    public void shootSpeaker() {
        topRightSpeed = SmartDashboard.getNumber("TR-RPM", defaultRPM);
        topLeftSpeed = SmartDashboard.getNumber("TL-RPM", defaultRPM);
        bottomLeft.set(1);
        midLeft.set(1);
        topLeft.set(topLeftSpeed / Constants.MaxRPMConstants.maxRPMVortex);
        topRight.set(topRightSpeed / Constants.MaxRPMConstants.maxRPMVortex);
    }

    public void shootAmp() {
        topRightSpeed = SmartDashboard.getNumber("TR-RPM", defaultRPM);
        topLeftSpeed = SmartDashboard.getNumber("TL-RPM", defaultRPM);
        bottomLeft.set(1);
        midLeft.set(1);
        topRight.set(topRightSpeed / Constants.MaxRPMConstants.maxRPMVortex);
    }

    public void stopall() {
        bottomLeft.set(0);
        midLeft.set(0);
        topLeft.set(0);
        topRight.set(0);
    }

    boolean isNoteInSpamp() {
        return noteDetectorSpampBottom.get();
    }

    public boolean isDoneShooting() {
        return !noteDetectorSpampBottom.get() && !noteDetectorSpampTop.get();
    }

    public void runBottom() {

        bottomLeft.set(.2);
        midLeft.set(.2);

    }

    public void intakeFromSpamp() {
        if (!isNoteInSpamp()) {
            bottomRightSpeed = -SmartDashboard.getNumber("BR-RPM", defaultRPM);
            topRightSpeed = -SmartDashboard.getNumber("TR-RPM", defaultRPM);
            topLeftSpeed = -SmartDashboard.getNumber("TL-RPM", defaultRPM);
            midLeft.set(bottomRightSpeed / midLeftGearRatio);
            topLeft.set(topLeftSpeed / Constants.MaxRPMConstants.maxRPMVortex);
            topRight.set(topRightSpeed / Constants.MaxRPMConstants.maxRPMVortex);
        } else {
            stopall();
        }
    }

    public void deployShooter() {
        shootSolenoid.set(Value.kForward);
    }

    public void retractShooter() {
        shootSolenoid.set(Value.kReverse);
    }

    public void runTopAmp() {
        topRight.set(-topRightSpeed / Constants.MaxRPMConstants.maxRPMVortex);
        midLeft.set(topRightSpeed / Constants.MaxRPMConstants.maxRPMNeo);
        bottomLeft.set(.25);
    }

    public void runTopShooter() {
        topRightSpeed = -SmartDashboard.getNumber("TR-RPM", defaultRPM);
        topLeftSpeed = -SmartDashboard.getNumber("TL-RPM", defaultRPM);
        topLeft.set(topLeftSpeed / Constants.MaxRPMConstants.maxRPMVortex);
        topRight.set(topRightSpeed / Constants.MaxRPMConstants.maxRPMVortex);
    }

    public void speakerAutonShoot() {
        if(topRight.getEncoder().getVelocity() > Constants.SpampConstants.speakerRPM) {
            //TODO: Change to account for PID, change line above ^
            bottomLeft.set(1);
            midLeft.set(1);
            topLeft.set(topLeftSpeed / Constants.MaxRPMConstants.maxRPMVortex);
            topRight.set(topRightSpeed / Constants.MaxRPMConstants.maxRPMVortex);
        }
    }
}
